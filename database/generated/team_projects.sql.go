// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: team_projects.sql

package generated

import (
	"context"
	"database/sql"
)

const addTeamProjectMember = `-- name: AddTeamProjectMember :one
INSERT INTO team_project_members (project_id, user_id)
VALUES ($1, $2)
RETURNING id, project_id, user_id, joined_at
`

type AddTeamProjectMemberParams struct {
	ProjectID int32 `db:"project_id" json:"project_id"`
	UserID    int32 `db:"user_id" json:"user_id"`
}

func (q *Queries) AddTeamProjectMember(ctx context.Context, arg AddTeamProjectMemberParams) (TeamProjectMember, error) {
	row := q.db.QueryRowContext(ctx, addTeamProjectMember, arg.ProjectID, arg.UserID)
	var i TeamProjectMember
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.UserID,
		&i.JoinedAt,
	)
	return i, err
}

const checkTeamProjectMember = `-- name: CheckTeamProjectMember :one
SELECT EXISTS(
    SELECT 1 FROM team_project_members 
    WHERE project_id = $1 AND user_id = $2
) as is_member
`

type CheckTeamProjectMemberParams struct {
	ProjectID int32 `db:"project_id" json:"project_id"`
	UserID    int32 `db:"user_id" json:"user_id"`
}

func (q *Queries) CheckTeamProjectMember(ctx context.Context, arg CheckTeamProjectMemberParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, checkTeamProjectMember, arg.ProjectID, arg.UserID)
	var is_member bool
	err := row.Scan(&is_member)
	return is_member, err
}

const createTeamProject = `-- name: CreateTeamProject :one
INSERT INTO team_projects (name, code, created_by)
VALUES ($1, $2, $3)
RETURNING id, name, code, created_by, created_at, updated_at
`

type CreateTeamProjectParams struct {
	Name      string `db:"name" json:"name"`
	Code      string `db:"code" json:"code"`
	CreatedBy int32  `db:"created_by" json:"created_by"`
}

func (q *Queries) CreateTeamProject(ctx context.Context, arg CreateTeamProjectParams) (TeamProject, error) {
	row := q.db.QueryRowContext(ctx, createTeamProject, arg.Name, arg.Code, arg.CreatedBy)
	var i TeamProject
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createTeamTask = `-- name: CreateTeamTask :one
INSERT INTO team_tasks (project_id, title, description, done, created_by, deadline)
VALUES ($1, $2, $3, false, $4, $5)
RETURNING id, project_id, title, description, done, created_by, created_at, updated_at, deadline
`

type CreateTeamTaskParams struct {
	ProjectID   int32          `db:"project_id" json:"project_id"`
	Title       string         `db:"title" json:"title"`
	Description sql.NullString `db:"description" json:"description"`
	CreatedBy   int32          `db:"created_by" json:"created_by"`
	Deadline    sql.NullTime   `db:"deadline" json:"deadline"`
}

func (q *Queries) CreateTeamTask(ctx context.Context, arg CreateTeamTaskParams) (TeamTask, error) {
	row := q.db.QueryRowContext(ctx, createTeamTask,
		arg.ProjectID,
		arg.Title,
		arg.Description,
		arg.CreatedBy,
		arg.Deadline,
	)
	var i TeamTask
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Title,
		&i.Description,
		&i.Done,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deadline,
	)
	return i, err
}

const deleteTeamTask = `-- name: DeleteTeamTask :exec
DELETE FROM team_tasks WHERE id = $1 AND project_id = $2
`

type DeleteTeamTaskParams struct {
	ID        int32 `db:"id" json:"id"`
	ProjectID int32 `db:"project_id" json:"project_id"`
}

func (q *Queries) DeleteTeamTask(ctx context.Context, arg DeleteTeamTaskParams) error {
	_, err := q.db.ExecContext(ctx, deleteTeamTask, arg.ID, arg.ProjectID)
	return err
}

const getTeamProjectByCode = `-- name: GetTeamProjectByCode :one
SELECT id, name, code, created_by, created_at, updated_at FROM team_projects WHERE code = $1
`

func (q *Queries) GetTeamProjectByCode(ctx context.Context, code string) (TeamProject, error) {
	row := q.db.QueryRowContext(ctx, getTeamProjectByCode, code)
	var i TeamProject
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTeamProjectByID = `-- name: GetTeamProjectByID :one
SELECT id, name, code, created_by, created_at, updated_at FROM team_projects WHERE id = $1
`

func (q *Queries) GetTeamProjectByID(ctx context.Context, id int32) (TeamProject, error) {
	row := q.db.QueryRowContext(ctx, getTeamProjectByID, id)
	var i TeamProject
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Code,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getTeamProjectMembers = `-- name: GetTeamProjectMembers :many
SELECT u.id, u.username, u.email, tpm.joined_at
FROM team_project_members tpm
JOIN users u ON tpm.user_id = u.id
WHERE tpm.project_id = $1
ORDER BY tpm.joined_at ASC
`

type GetTeamProjectMembersRow struct {
	ID       int32          `db:"id" json:"id"`
	Username string         `db:"username" json:"username"`
	Email    sql.NullString `db:"email" json:"email"`
	JoinedAt sql.NullTime   `db:"joined_at" json:"joined_at"`
}

func (q *Queries) GetTeamProjectMembers(ctx context.Context, projectID int32) ([]GetTeamProjectMembersRow, error) {
	rows, err := q.db.QueryContext(ctx, getTeamProjectMembers, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamProjectMembersRow
	for rows.Next() {
		var i GetTeamProjectMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Email,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTeamTaskByID = `-- name: GetTeamTaskByID :one
SELECT tt.id, tt.project_id, tt.title, tt.description, tt.done, tt.created_by, tt.created_at, tt.updated_at, tt.deadline, u.username as created_by_username
FROM team_tasks tt
JOIN users u ON tt.created_by = u.id
WHERE tt.id = $1 AND tt.project_id = $2
`

type GetTeamTaskByIDParams struct {
	ID        int32 `db:"id" json:"id"`
	ProjectID int32 `db:"project_id" json:"project_id"`
}

type GetTeamTaskByIDRow struct {
	ID                int32          `db:"id" json:"id"`
	ProjectID         int32          `db:"project_id" json:"project_id"`
	Title             string         `db:"title" json:"title"`
	Description       sql.NullString `db:"description" json:"description"`
	Done              sql.NullBool   `db:"done" json:"done"`
	CreatedBy         int32          `db:"created_by" json:"created_by"`
	CreatedAt         sql.NullTime   `db:"created_at" json:"created_at"`
	UpdatedAt         sql.NullTime   `db:"updated_at" json:"updated_at"`
	Deadline          sql.NullTime   `db:"deadline" json:"deadline"`
	CreatedByUsername string         `db:"created_by_username" json:"created_by_username"`
}

func (q *Queries) GetTeamTaskByID(ctx context.Context, arg GetTeamTaskByIDParams) (GetTeamTaskByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getTeamTaskByID, arg.ID, arg.ProjectID)
	var i GetTeamTaskByIDRow
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Title,
		&i.Description,
		&i.Done,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deadline,
		&i.CreatedByUsername,
	)
	return i, err
}

const getTeamTasks = `-- name: GetTeamTasks :many
SELECT tt.id, tt.project_id, tt.title, tt.description, tt.done, tt.created_by, tt.created_at, tt.updated_at, tt.deadline, u.username as created_by_username
FROM team_tasks tt
JOIN users u ON tt.created_by = u.id
WHERE tt.project_id = $1
ORDER BY tt.created_at DESC
`

type GetTeamTasksRow struct {
	ID                int32          `db:"id" json:"id"`
	ProjectID         int32          `db:"project_id" json:"project_id"`
	Title             string         `db:"title" json:"title"`
	Description       sql.NullString `db:"description" json:"description"`
	Done              sql.NullBool   `db:"done" json:"done"`
	CreatedBy         int32          `db:"created_by" json:"created_by"`
	CreatedAt         sql.NullTime   `db:"created_at" json:"created_at"`
	UpdatedAt         sql.NullTime   `db:"updated_at" json:"updated_at"`
	Deadline          sql.NullTime   `db:"deadline" json:"deadline"`
	CreatedByUsername string         `db:"created_by_username" json:"created_by_username"`
}

func (q *Queries) GetTeamTasks(ctx context.Context, projectID int32) ([]GetTeamTasksRow, error) {
	rows, err := q.db.QueryContext(ctx, getTeamTasks, projectID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetTeamTasksRow
	for rows.Next() {
		var i GetTeamTasksRow
		if err := rows.Scan(
			&i.ID,
			&i.ProjectID,
			&i.Title,
			&i.Description,
			&i.Done,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Deadline,
			&i.CreatedByUsername,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTeamProjects = `-- name: GetUserTeamProjects :many
SELECT tp.id, tp.name, tp.code, tp.created_by, tp.created_at, tp.updated_at, tpm.joined_at
FROM team_projects tp
JOIN team_project_members tpm ON tp.id = tpm.project_id
WHERE tpm.user_id = $1
ORDER BY tpm.joined_at DESC
`

type GetUserTeamProjectsRow struct {
	ID        int32        `db:"id" json:"id"`
	Name      string       `db:"name" json:"name"`
	Code      string       `db:"code" json:"code"`
	CreatedBy int32        `db:"created_by" json:"created_by"`
	CreatedAt sql.NullTime `db:"created_at" json:"created_at"`
	UpdatedAt sql.NullTime `db:"updated_at" json:"updated_at"`
	JoinedAt  sql.NullTime `db:"joined_at" json:"joined_at"`
}

func (q *Queries) GetUserTeamProjects(ctx context.Context, userID int32) ([]GetUserTeamProjectsRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserTeamProjects, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserTeamProjectsRow
	for rows.Next() {
		var i GetUserTeamProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Code,
			&i.CreatedBy,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.JoinedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isUserMemberOfProject = `-- name: IsUserMemberOfProject :one
SELECT EXISTS(
    SELECT 1 FROM team_project_members 
    WHERE project_id = $1 AND user_id = $2
) as is_member
`

type IsUserMemberOfProjectParams struct {
	ProjectID int32 `db:"project_id" json:"project_id"`
	UserID    int32 `db:"user_id" json:"user_id"`
}

func (q *Queries) IsUserMemberOfProject(ctx context.Context, arg IsUserMemberOfProjectParams) (bool, error) {
	row := q.db.QueryRowContext(ctx, isUserMemberOfProject, arg.ProjectID, arg.UserID)
	var is_member bool
	err := row.Scan(&is_member)
	return is_member, err
}

const setTeamTaskDone = `-- name: SetTeamTaskDone :one
UPDATE team_tasks 
SET done = $2, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND project_id = $3
RETURNING id, project_id, title, description, done, created_by, created_at, updated_at, deadline
`

type SetTeamTaskDoneParams struct {
	ID        int32        `db:"id" json:"id"`
	Done      sql.NullBool `db:"done" json:"done"`
	ProjectID int32        `db:"project_id" json:"project_id"`
}

func (q *Queries) SetTeamTaskDone(ctx context.Context, arg SetTeamTaskDoneParams) (TeamTask, error) {
	row := q.db.QueryRowContext(ctx, setTeamTaskDone, arg.ID, arg.Done, arg.ProjectID)
	var i TeamTask
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Title,
		&i.Description,
		&i.Done,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deadline,
	)
	return i, err
}

const updateTeamTask = `-- name: UpdateTeamTask :one
UPDATE team_tasks 
SET title = $2, description = $3, deadline = $5, updated_at = CURRENT_TIMESTAMP
WHERE id = $1 AND project_id = $4
RETURNING id, project_id, title, description, done, created_by, created_at, updated_at, deadline
`

type UpdateTeamTaskParams struct {
	ID          int32          `db:"id" json:"id"`
	Title       string         `db:"title" json:"title"`
	Description sql.NullString `db:"description" json:"description"`
	ProjectID   int32          `db:"project_id" json:"project_id"`
	Deadline    sql.NullTime   `db:"deadline" json:"deadline"`
}

func (q *Queries) UpdateTeamTask(ctx context.Context, arg UpdateTeamTaskParams) (TeamTask, error) {
	row := q.db.QueryRowContext(ctx, updateTeamTask,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.ProjectID,
		arg.Deadline,
	)
	var i TeamTask
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.Title,
		&i.Description,
		&i.Done,
		&i.CreatedBy,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Deadline,
	)
	return i, err
}
