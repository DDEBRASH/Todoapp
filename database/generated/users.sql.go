// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: users.sql

package generated

import (
	"context"
	"database/sql"
)

const blockUser = `-- name: BlockUser :exec
UPDATE users
SET is_blocked = TRUE
WHERE id = $1
`

func (q *Queries) BlockUser(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, blockUser, id)
	return err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (username, email, password_hash)
VALUES ($1, $2, $3)
RETURNING id, username, email, password_hash
`

type CreateUserParams struct {
	Username     string         `db:"username" json:"username"`
	Email        sql.NullString `db:"email" json:"email"`
	PasswordHash string         `db:"password_hash" json:"password_hash"`
}

type CreateUserRow struct {
	ID           int32          `db:"id" json:"id"`
	Username     string         `db:"username" json:"username"`
	Email        sql.NullString `db:"email" json:"email"`
	PasswordHash string         `db:"password_hash" json:"password_hash"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (CreateUserRow, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Username, arg.Email, arg.PasswordHash)
	var i CreateUserRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Email,
		&i.PasswordHash,
	)
	return i, err
}

const getPasswordReset = `-- name: GetPasswordReset :one
SELECT id, user_id, token, expires_at, used, created_at FROM password_reset_tokens WHERE token = $1
`

func (q *Queries) GetPasswordReset(ctx context.Context, token string) (PasswordResetToken, error) {
	row := q.db.QueryRowContext(ctx, getPasswordReset, token)
	var i PasswordResetToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Token,
		&i.ExpiresAt,
		&i.Used,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, username, password_hash, email, is_blocked, failed_attempts
FROM users
WHERE email = $1
`

type GetUserByEmailRow struct {
	ID             int32          `db:"id" json:"id"`
	Username       string         `db:"username" json:"username"`
	PasswordHash   string         `db:"password_hash" json:"password_hash"`
	Email          sql.NullString `db:"email" json:"email"`
	IsBlocked      bool           `db:"is_blocked" json:"is_blocked"`
	FailedAttempts int32          `db:"failed_attempts" json:"failed_attempts"`
}

func (q *Queries) GetUserByEmail(ctx context.Context, email sql.NullString) (GetUserByEmailRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i GetUserByEmailRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.Email,
		&i.IsBlocked,
		&i.FailedAttempts,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, username, password_hash, failed_attempts, is_blocked, email, email_verified
FROM users
WHERE id = $1
`

func (q *Queries) GetUserByID(ctx context.Context, id int32) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.FailedAttempts,
		&i.IsBlocked,
		&i.Email,
		&i.EmailVerified,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, username, password_hash, failed_attempts, is_blocked, email
FROM users
WHERE username = $1
`

type GetUserByUsernameRow struct {
	ID             int32          `db:"id" json:"id"`
	Username       string         `db:"username" json:"username"`
	PasswordHash   string         `db:"password_hash" json:"password_hash"`
	FailedAttempts int32          `db:"failed_attempts" json:"failed_attempts"`
	IsBlocked      bool           `db:"is_blocked" json:"is_blocked"`
	Email          sql.NullString `db:"email" json:"email"`
}

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (GetUserByUsernameRow, error) {
	row := q.db.QueryRowContext(ctx, getUserByUsername, username)
	var i GetUserByUsernameRow
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.PasswordHash,
		&i.FailedAttempts,
		&i.IsBlocked,
		&i.Email,
	)
	return i, err
}

const incrementFailedAttempts = `-- name: IncrementFailedAttempts :exec
UPDATE users 
SET failed_attempts = failed_attempts + 1, last_failed = NOW() 
WHERE id = $1
`

func (q *Queries) IncrementFailedAttempts(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, incrementFailedAttempts, id)
	return err
}

const resetFailedAttempts = `-- name: ResetFailedAttempts :exec
UPDATE users SET failed_attempts = 0 WHERE id = $1
`

func (q *Queries) ResetFailedAttempts(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, resetFailedAttempts, id)
	return err
}

const setPasswordHash = `-- name: SetPasswordHash :exec
UPDATE users SET password_hash = $2 WHERE id = $1
`

type SetPasswordHashParams struct {
	ID           int32  `db:"id" json:"id"`
	PasswordHash string `db:"password_hash" json:"password_hash"`
}

func (q *Queries) SetPasswordHash(ctx context.Context, arg SetPasswordHashParams) error {
	_, err := q.db.ExecContext(ctx, setPasswordHash, arg.ID, arg.PasswordHash)
	return err
}

const setUserPassword = `-- name: SetUserPassword :exec
UPDATE users SET password_hash = $2 WHERE id = $1
`

type SetUserPasswordParams struct {
	ID           int32  `db:"id" json:"id"`
	PasswordHash string `db:"password_hash" json:"password_hash"`
}

func (q *Queries) SetUserPassword(ctx context.Context, arg SetUserPasswordParams) error {
	_, err := q.db.ExecContext(ctx, setUserPassword, arg.ID, arg.PasswordHash)
	return err
}
